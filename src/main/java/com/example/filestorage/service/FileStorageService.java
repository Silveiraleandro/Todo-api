package com.example.filestorage.service;

import com.example.filestorage.model.FileMetadata;
import com.example.filestorage.repository.FileMetadataRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class FileStorageService {

    private final Path rootLocation;
    private final FileMetadataRepository repository;

    public FileStorageService(@Value("${storage.location:uploads}") String storageLocation,
                              FileMetadataRepository repository) throws IOException {
        this.rootLocation = Paths.get(storageLocation);
        this.repository = repository;

        if (!Files.exists(rootLocation)) {
            Files.createDirectories(rootLocation);
        }
    }

    @PostConstruct
    void init() {
        try {
            Files.createDirectories(rootLocation);
        } catch(IOException e) {
            throw new IllegalStateException("Could not create upload directory: " + rootLocation);
        }
    }

    public FileMetadata store(MultipartFile file) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Cannot store empty file");
        }

        // Sanitize original filename (prevent traversal)
        String originalName = Paths.get(file.getOriginalFilename()).getFileName().toString();

        // Reject weird names just in case (defense-in-depth)
        if (originalName.contains("..") || originalName.contains("/") || originalName.contains("\\")) {
            throw new IllegalArgumentException("Invalid original filename");
        }

        // Generate collision-safe stored name that WE control
        String storedName = java.util.UUID.randomUUID() + "_" + originalName;

        // Build destination under the configured root
        java.nio.file.Path destination = rootLocation.resolve(storedName).normalize();
        // NOTE: we don't need the startsWith(rootLocation) guard here because storedName is generated by us.

        try (java.io.InputStream in = file.getInputStream()) {
            java.nio.file.Files.copy(in, destination, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
        }

        FileMetadata meta = new FileMetadata(
                originalName,
                storedName,
                file.getSize(),
                java.time.LocalDateTime.now(),
                file.getContentType()
        );
        return repository.save(meta);
    }

    public byte[] loadBytes(String storaName) throws IOException {
        Path path = safeResolve(storaName);
        if (!Files.exists(path)) {
            throw new NoSuchFileException(storaName);
        }
        return Files.readAllBytes(path);
    }

    public List<FileMetadata> listFiles() {
        return repository.findAll();
    }

    public void delete(String storedName) throws IOException {
        // 404 if we don't have metadata
        var meta = repository.findByStoredName(storedName)
                .orElseThrow(() -> new java.nio.file.NoSuchFileException(storedName));

        java.nio.file.Path path = safeResolve(storedName);

        try {
            // Delete the file if it exists
            java.nio.file.Files.deleteIfExists(path);
        } catch (java.nio.file.AccessDeniedException e) {
            // workaround for Windows when the file is still locked by a process/AV
            throw new IllegalStateException("File is in use and cannot be deleted right now", e);
        }

        // Remove DB record last (only if the file op above succeeded)
        repository.delete(meta);
    }

    public Optional<FileMetadata> findByStored(String storedName) {
        return repository.findByStoredName(storedName);
    }

    public Path safeResolve(String storeName) {
        Path resolvedPath = rootLocation.resolve(storeName).normalize();
        if(!resolvedPath.startsWith(rootLocation)) {
            throw new SecurityException("Invalid file path");
        }
        return resolvedPath;
    }
}
